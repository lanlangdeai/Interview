PHP相关问答

1.请说明 PHP 中传值与传引用的区别，什么时候传值什么时候传引用?

	按值传递：函数范围内对值的任何改变在函数外部都会被忽略
	按引用传递：函数范围内对值的任何改变在函数外部也能反映出这些修改

	优缺点：按值传递时，php必须复制值。特别是对于大型的字符串和对象来说，这将会是一个代价很大的操作。按引用传递则不需要复制值，对于性能提高很有好处。（优缺点会考到）

2.说一下单引号双引号？

	单引号内部的变量不会执行， 双引号会执行

	单引号解析速度比双引号快。

	单引号只能解析部分特殊字符，双引号可以解析所有特殊字符

3.PHP7的新特性？

	标量类型声明：PHP 7 中的函数的形参类型声明可以是标量了。在 PHP 5 中只能是类名、接口、array 或者 callable (PHP 5.4，即可以是函数，包括匿名函数)，现在也可以使用 string、int、float和 bool 了。

	返回值类型声明：增加了对返回类型声明的支持。 类似于参数类型声明，返回类型声明指明了函数返回值的类型。可用的类型与参数声明中可用的类型相同。

	NULL 合并运算符：由于日常使用中存在大量同时使用三元表达式和 isset()的情况，NULL 合并运算符使得变量存在且值不为NULL， 它就会返回自身的值，否则返回它的第二个操作数。

	use 加强：从同一 namespace 导入的类、函数和常量现在可以通过单个 use 语句 一次性导入了

	匿名类：现在支持通过new class 来实例化一个匿名类
	
	<=> 比较运算符:就是看两个表达式值的大小，三种关系： = 返回0、< 返回-1、 > 返回 1

	define支持定义数组类型的值

	增加了整除函数 intdiv

	顺便说一下5.6中的新特性:
		1.类中使用表达式定义常量,可以使用常量来定义数组
		2.使用 ... 运算符定义变长参数函数,使用 ... 运算符进行参数展开
		3.使用 ** 进行幂运算
		

4.什么是依赖注入(DI)
	依赖注入是通过类的构造函数、方法、或者直接写入的方式，将所依赖的组件传递给类的方式。
	只要不是由内部生产（比如初始化、构造函数 __construct 中通过工厂方法、自行手动 new 的），而是由外部以参数或其他形式注入的，都属于依赖注入（DI）

	DI是IOC(控制反转)的一种设计模式,将类依赖另一个类的实例移到类的外部实现
	IOC:IOC是DIP的一种具体思路，将上层所依赖的下层交由第三方实现。也就是说，是在A类中主动去获所需要的外部资源C，这种情况被称为正向的。那么什么是反向呢？就是A类不再主去获取C，而是被动等待，等待IoC/DI的容器获取一个C的实例，然后反向的注入到A类中。


5.PHP常用的设计模式
	1)单例模式(数据库)
		所谓单例模式，就是确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例，即在应用程序中只会有这个类的一个实例存在。
		单例模式有以下3个特点：

			1．只能有一个实例,必须拥有一个构造函数，并且必须被标记为private
			2．必须自行创建这个实例，拥有一个保存类的实例的静态成员变量
			3．必须给其他对象提供这一实例，拥有一个访问这个实例的公共的静态方法
	2)依赖注入模式
		依赖注入（Dependency Injection）是控制反转（Inversion of Control）的一种实现方式。


	3)门面模式


6.PHP代码的执行过程
	1).Scanning(Lexing) ,将PHP代码转换为语言片段(Tokens)
	2).Parsing, 将Tokens转换成简单而有意义的表达式
	3).Compilation, 将表达式编译成Opcodes
	4).Execution, 顺次执行Opcodes，每次一条，从而实现PHP脚本的功能。

	现在有的Cache比如APC,可以使得PHP缓存住Opcodes，这样，每次有请求来临的时候，就不需要重复执行前面3步，从而能大幅的提高PHP的执行速度。

7.如何实现session共享
	默认session是保存在磁盘文件中
	配置项:
		session.save_handler = files(文件)  指定存储方式
		session.save_path="N;/path" 指定保存的路径. N标识生成几级目录
		session.name = PHPSESSID cookie名称

	实现方式:
		1)将session存储到客户端cookie中(将其进行加密)
			好处:不会出现多台服务器无法读取session的问题
			弊端:每次请求都需要传递给服务器
				浏览器对于cookie有大小的限制

			不适合高访问量,一般一个cookie为2k
		2)使用一个算法,什么机制下session是保存在哪台服务器下，那么读取的时候就按照这种规则去读取，就能定位到原来的服务器。叫做分发请求，分发到特定的服务器上去，我理解其原理是存session和读session数据保证都在一台服务器操作，就不会需要涉及到共享，具体实现方式是通过约定一种分发机制来实现。

		弊端:因为某种规则的session都是保存在一台服务器上，比如用户编号是1-200涉及到的session数据保存到a服务器上去。所以只要一台出问题，1-200的用户就无法实现登录了。后面就不可用了(可能想到1-200用户的session服务器用多台进行复制，这感觉很蹩脚，仍然需要用到复制的话，还不如用其他简便的方法)

		3)做一个中间层，专门来存储所有访问涉及到的session。也就是所有的session都存储在这里。
			I)NFS文件共享方式,多台PHP服务器共享session文件的磁盘
			II)保存到数据库中，这种方式的扩展性很强，可以随意增加WEB而不受影响。放在数据库里面安全方面好。
			III)可以将session数据保存在memcached，redis之类内存数据库中，memcached是基于内存存储数据的，性能很高，用户并发量很大的时候尤其合适
			
