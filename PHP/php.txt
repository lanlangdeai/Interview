PHP相关问答

1.请说明 PHP 中传值与传引用的区别，什么时候传值什么时候传引用?

	按值传递：函数范围内对值的任何改变在函数外部都会被忽略
	按引用传递：函数范围内对值的任何改变在函数外部也能反映出这些修改

	优缺点：按值传递时，php必须复制值。特别是对于大型的字符串和对象来说，这将会是一个代价很大的操作。按引用传递则不需要复制值，对于性能提高很有好处。（优缺点会考到）

2.说一下单引号双引号？

	单引号内部的变量不会执行， 双引号会执行

	单引号解析速度比双引号快。

	单引号只能解析部分特殊字符，双引号可以解析所有特殊字符

3.PHP7的新特性？

	标量类型声明：PHP 7 中的函数的形参类型声明可以是标量了。在 PHP 5 中只能是类名、接口、array 或者 callable (PHP 5.4，即可以是函数，包括匿名函数)，现在也可以使用 string、int、float和 bool 了。

	返回值类型声明：增加了对返回类型声明的支持。 类似于参数类型声明，返回类型声明指明了函数返回值的类型。可用的类型与参数声明中可用的类型相同。

	NULL 合并运算符：由于日常使用中存在大量同时使用三元表达式和 isset()的情况，NULL 合并运算符使得变量存在且值不为NULL， 它就会返回自身的值，否则返回它的第二个操作数。

	use 加强：从同一 namespace 导入的类、函数和常量现在可以通过单个 use 语句 一次性导入了

	匿名类：现在支持通过new class 来实例化一个匿名类
	
	<=> 比较运算符:就是看两个表达式值的大小，三种关系： = 返回0、< 返回-1、 > 返回 1

	define支持定义数组类型的值

	增加了整除函数 intdiv

	顺便说一下5.6中的新特性:
		1.类中使用表达式定义常量,可以使用常量来定义数组
		2.使用 ... 运算符定义变长参数函数,使用 ... 运算符进行参数展开
		3.使用 ** 进行幂运算
		

4.什么是依赖注入(DI)
	依赖注入是通过类的构造函数、方法、或者直接写入的方式，将所依赖的组件传递给类的方式。
	只要不是由内部生产（比如初始化、构造函数 __construct 中通过工厂方法、自行手动 new 的），而是由外部以参数或其他形式注入的，都属于依赖注入（DI）

	DI是IOC(控制反转)的一种设计模式,将类依赖另一个类的实例移到类的外部实现
	IOC:IOC是DIP的一种具体思路，将上层所依赖的下层交由第三方实现。也就是说，是在A类中主动去获所需要的外部资源C，这种情况被称为正向的。那么什么是反向呢？就是A类不再主去获取C，而是被动等待，等待IoC/DI的容器获取一个C的实例，然后反向的注入到A类中。


5.PHP常用的设计模式
	1)单例模式(数据库)
		所谓单例模式，就是确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例，即在应用程序中只会有这个类的一个实例存在。
		单例模式有以下3个特点：

			1．只能有一个实例,必须拥有一个构造函数，并且必须被标记为private
			2．必须自行创建这个实例，拥有一个保存类的实例的静态成员变量
			3．必须给其他对象提供这一实例，拥有一个访问这个实例的公共的静态方法
	2)依赖注入模式
		依赖注入（Dependency Injection）是控制反转（Inversion of Control）的一种实现方式。


	3)门面模式


6.PHP代码的执行过程
	1).Scanning(Lexing) ,将PHP代码转换为语言片段(Tokens)
	2).Parsing, 将Tokens转换成简单而有意义的表达式
	3).Compilation, 将表达式编译成Opcodes
	4).Execution, 顺次执行Opcodes，每次一条，从而实现PHP脚本的功能。

	现在有的Cache比如APC,可以使得PHP缓存住Opcodes，这样，每次有请求来临的时候，就不需要重复执行前面3步，从而能大幅的提高PHP的执行速度。

7.如何实现session共享
	默认session是保存在磁盘文件中
	配置项:
		session.save_handler = files(文件)  指定存储方式
		session.save_path="N;/path" 指定保存的路径. N标识生成几级目录
		session.name = PHPSESSID cookie名称

	实现方式:
		1)将session存储到客户端cookie中(将其进行加密)
			好处:不会出现多台服务器无法读取session的问题
			弊端:每次请求都需要传递给服务器
				浏览器对于cookie有大小的限制

			不适合高访问量,一般一个cookie为2k
		2)使用一个算法,什么机制下session是保存在哪台服务器下，那么读取的时候就按照这种规则去读取，就能定位到原来的服务器。叫做分发请求，分发到特定的服务器上去，我理解其原理是存session和读session数据保证都在一台服务器操作，就不会需要涉及到共享，具体实现方式是通过约定一种分发机制来实现。

		弊端:因为某种规则的session都是保存在一台服务器上，比如用户编号是1-200涉及到的session数据保存到a服务器上去。所以只要一台出问题，1-200的用户就无法实现登录了。后面就不可用了(可能想到1-200用户的session服务器用多台进行复制，这感觉很蹩脚，仍然需要用到复制的话，还不如用其他简便的方法)

		3)做一个中间层，专门来存储所有访问涉及到的session。也就是所有的session都存储在这里。
			I)NFS文件共享方式,多台PHP服务器共享session文件的磁盘
			II)保存到数据库中，这种方式的扩展性很强，可以随意增加WEB而不受影响。放在数据库里面安全方面好。
			III)可以将session数据保存在memcached，redis之类内存数据库中，memcached是基于内存存储数据的，性能很高，用户并发量很大的时候尤其合适
			
8.如何记录PHP的错误信息？
	php.ini的相关配置项，这两个配置项为：

参数					配置项				说明

log_errors      	On/off              是否开启日志记录

log_errors_max_len  整型，默认1024     	单行错误最大记录长度

error_log			syslog或者指定路径		错误日志记录在什么地方


9.PHP中的错误级别？
    Deprecated 最低级别错误，程序继续执行

　  Notice 通知级别的错误 如直接使用未声明变量，程序继续执行

　  Warning 警告级别的错误，可能得不到想要的结果

　  Fatal error  致命级别错误致命级别错误，程序不往下执行

　  parse error 语法解析错误，最高级别错误，连其他错误信息也不呈现出来

　  E_USER_相关错误 用户设置的相关错误

10.PHP-fpm配置调优？

pm = dynamic; 表示使用哪种进程数量管理方式

　　　　dynamic表示php-fpm进程数是动态的，最开始是pm.start_servers指定的数量，如果请求较多，则会自动增加，保证空闲的进程数不小于pm.min_spare_servers，如果进程数较多，也会进行相应清理，保证多余的进程数不多于pm.max_spare_servers

　　　　static表示php-fpm进程数是静态的, 进程数自始至终都是pm.max_children指定的数量，不再增加或减少

　　pm.max_children = 300; 静态方式下开启的php-fpm进程数量
　　pm.start_servers = 20; 动态方式下的起始php-fpm进程数量
　　pm.min_spare_servers = 5; 动态方式下的最小php-fpm进程数量
　　pm.max_spare_servers = 35; 动态方式下的最大php-fpm进程数量

　　　　如果pm为static, 那么其实只有pm.max_children这个参数生效。系统会开启设置数量的php-fpm进程

　　　　如果pm为dynamic, 那么pm.max_children参数失效，后面3个参数生效。系统会在php-fpm运行开始的时候启动pm.start_servers个php-fpm进程，然后根据系统的需求动态在pm.min_spare_servers和pm.max_spare_servers之间调整php-fpm进程数
	例如，命令strace -o out.txt -T -tt -e trace=all -p 2899表示跟踪2899进程的所有系统调用，并统计系统调用的时间开销，以及调用起始时间(以可视化的时分秒格式显示)，最后将记录结果存入out.txt文件。

pm.max_requests = 10240; 
发送多少个请求后会重启该线程。最大处理请求数是指一个php-fpm的worker进程在处理多少个请求后就终止掉，master进程会重新respawn一个新的。
这个配置的主要目的是避免php解释器或程序引用的第三方库造成的内存泄露。

max_execution_time
request_terminate_timeout = 30; 脚本最大执行时间


11.对于PHP性能进行监控
开启xdebug的性能监控功能


12.排查PHP-fpm占用CPU过高
php-fmp.conf中开启错误日志，慢执行日志还有常规日志
使用strace工具进行性能分析
	例如，命令strace -o out.txt -T -tt -e trace=all -p 2899表示跟踪2899进程的所有系统调用，并统计系统调用的时间开销，以及调用起始时间(以可视化的时分秒格式显示)，最后将记录结果存入out.txt文件。





