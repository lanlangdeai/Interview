MySQL有关问题

1.MySQL数据库中的字段类型varchar和char的主要区别是什么?

Varchar是变长，节省存储空间，char是固定长度。查找效率char型更快，因为varchar是非定长，必须先查找长度，然后进行数据的提取，比char定长类型多了一个步骤，所以效率低一些。
后面的数字代表的是字符的长度，并不代表字节，字节是固定的占用

2.MySQL数据库的常用存储引擎以及它们的区别？

MyISAM：
	不支持事务，表锁，易产生碎片，要经常优化，读写速度较快，支持全文索引。
	myisam会创建三个文件： 
		1.xxx(表名).frm –>表结构 
		2.xxx(表名).myi –>索引 
		3.xxx(表名).myd –>数据文件

InnoDB：
	支持外键，事务，行锁，有崩溃恢复能力。读写速度比MyISAM慢，5.6之后支持全文索引。
	存储引擎是基于表的，而不是数据库 
	innodb会创建两个文件:
		1.xxx(表名).frm ->表结构
		2.xxx(表名).ibd ->数据+索引

3.Mysql的读写分离?

读写分离的实现原理就是在执行SQL语句的时候，判断到底是读操作还是写操作，把读的操作转向到读服务器上（从服务器，一般是多台），写的操作转到写的服务器上（主服务器，一般是一台，视数据量来看）。当然为了保证多台数据库数据的一致性，需要主从复制。

MySQL读写分离基本原理是让master数据库处理写操作，slave数据库处理读操作。master将写操作的变更同步到各个slave节点。

	主从复制几种方式:
		同步复制

		所谓的同步复制，意思是master的变化，必须等待slave-1,slave-2,...,slave-n完成后才能返回。

		这样，显然不可取，也不是MYSQL复制的默认设置。比如，在WEB前端页面上，用户增加了条记录，需要等待很长时间。


		异步复制

		如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心。MYSQL的默认设置。


		半同步复制

		master只保证slaves中的一个操作成功，就返回，其他slave不管。

		这个功能，是由google为MYSQL引入的。


	常见问题:
		问题1：master的写操作，slaves被动的进行一样的操作，保持数据一致性，那么slave是否可以主动的进行写操作？

			假设slave可以主动的进行写操作，slave又无法通知master，这样就导致了master和slave数据不一致了。因此slave不应该进行写操作，至少是slave上涉及到复制的数据库不可以写。实际上，这里已经揭示了读写分离的概念。
 
		问题2：主从复制中，可以有N个slave,可是这些slave又不能进行写操作，要他们干嘛？

			可以实现数据备份。

			类似于高可用的功能，一旦master挂了，可以让slave顶上去，同时slave提升为master。

			异地容灾，比如master在北京，地震挂了，那么在上海的slave还可以继续。

			主要用于实现scale out,分担负载,可以将读的任务分散到slaves上。

		问题3：主从复制中有master,slave1,slave2,...等等这么多MYSQL数据库，那比如一个JAVA WEB应用到底应该连接哪个数据库?
 
			当 然，我们在应用程序中可以这样，insert/delete/update这些更新数据库的操作，用connection(for master)进行操作，select用connection(for slaves)进行操作。那我们的应用程序还要完成怎么从slaves选择一个来执行select，例如简单的轮循算法。

			这样的话，相当于应用程序完成了SQL语句的路由，而且与MYSQL的主从复制架构非常关联，一旦master挂了，某些slave挂了，那么应用程序就要修改了。能不能让应用程序与MYSQL的主从复制架构没有什么太多关系呢？
			找一个组件，application program只需要与它打交道，用它来完成MYSQL的代理，实现SQL语句的路由。
 			mysql proxy并不负责，怎么从众多的slaves挑一个？可以交给另一个组件(比如haproxy)来完成。
			这就是所谓的MYSQL READ WRITE SPLITE，MYSQL的读写分离。

		问题4：当master的二进制日志每产生一个事件，都需要发往slave，如果我们有N个slave,那是发N次，还是只发一次？

			如果只发一次，发给了slave-1，那slave-2,slave-3,...它们怎么办？

			显 然，应该发N次。实际上，在MYSQL master内部，维护N个线程，每一个线程负责将二进制日志文件发往对应的slave。master既要负责写操作，还的维护N个线程，负担会很重。可 以这样，slave-1是master的从，slave-1又是slave-2,slave-3,...的主，同时slave-1不再负责select。 slave-1将master的复制线程的负担，转移到自己的身上。这就是所谓的多级复制的概念。

		问题5：当一个select发往mysqlproxy，可能这次由slave-2响应，下次由slave-3响应，这样的话，就无法利用查询缓存了。

			应该找一个共享式的缓存，比如memcache来解决。将slave-2,slave-3,...这些查询的结果都缓存至mamcache中

4.mysql索引类型Btree和Hash的区别?
	一般默认的索引类型是Btree类型
	Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。
可能很多人又有疑问了，既然 Hash 索引的效率要比 B-Tree 高很多，为什么大家不都用 Hash 索引而还要使用 B-Tree 索引呢？任何事物都是有两面性的，Hash 索引也一样，虽然 Hash 索引效率高，但是 Hash 索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些。

	（1）Hash 索引仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询。

	由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。

	（2）Hash 索引无法被用来避免数据的排序操作。

	由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；

	（3）Hash 索引不能利用部分索引键查询。

	对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。

	（4）Hash 索引在任何时候都不能避免表扫描。

	前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。

	（5）Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。

	对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下


5.数据库调优
	一、架构层面

		1、做主从复制。
		2、实现读写分离。
		3、分库分表。

	二、系统层面

		1、增加内存。
		2、硬盘使用固态硬盘 SSD。
		3、给磁盘做 raid0 或者 raid5 以增加磁盘的读写速度。
		4、可以重新挂载磁盘，并加上 noatime 参数，这样可以减少磁盘的 I/O。

	三、MySQL本身的优化

		1、如果未配置主从同步，可以把 bin-log 功能关闭，减少磁盘 I/O。
		2、在 my.cnf 中加上 skip-name-resolve ，这样可以避免由于解析主机名延迟造成 M有SQL 执行慢。
		3、调整几个关键的 buffer 和 cache。调整的依据，主要根据数据库的状态来调试。如何调优可以参考五。
		4、根据具体的使用场景，选择合适的存储引擎。

		四、应用层次

		查看慢查询日志，根据慢查询日志优化程序中的 SQL 语句，比如增加索引

	五、调整关键的buffer和cache

		1、key_buffer_size

		首先可以根据系统的内存大小设定它，大概的一个参考值：1G以下内存设定 128M；2G/256M; 4G/384M; 8G/1024M；16G/2048M。这个值可以通过检查状态值 Key_read_requests 和 Key_reads，可以知道 key_buffer_size 设置是否合理。比例 key_reads / key_read_requests 应该尽可能的低，至少是 1:100，1:1000更好(上述状态值可以使用 SHOW STATUS LIKE 'key_read%' 获得)。注意：该参数值设置的过大反而会是服务器整体效率降低!

		2、table_open_cache

		打开一个表的时候，会临时把表里面的数据放到这部分内存中，一般设置成 1024 就够了，它的大小我们可以通过这样的方法来衡量： 如果你发现 open_tables 等于 table_cache，并且 opened_tables 在不断增长，那么你就需要增加 table_cache 的值了(上述状态值可以使用 SHOW STATUS LIKE 'Open%tables' 获得)。注意，不能盲目地把 table_cache 设置成很大的值。如果设置得太高，可能会造成文件描述符不足，从而造成性能不稳定或者连接失败。

		3、sort_buffer_size

		查询排序时所能使用的缓冲区大小,该参数对应的分配内存是每连接独占! 如果有 100 个连接，那么实际分配的总共排序缓冲区大小为100 × 4 = 400MB。所以，对于内存在 4GB 左右的服务器推荐设置为：4-8M。

		4、read_buffer_size

		读查询操作所能使用的缓冲区大小。和 sort_buffer_size 一样，该参数对应的分配内存也是每连接独享!

		5、join_buffer_size

		联合查询操作所能使用的缓冲区大小，和 sort_buffer_size 一样，该参数对应的分配内存也是每连接独享!

		6、myisam_sort_buffer_size

		这个缓冲区主要用于修复表过程中排序索引使用的内存或者是建立索引时排序索引用到的内存大小，一般 4G 内存给 64M 即可。

		7、query_cache_size

		MySQL查询操作缓冲区的大小，通过以下做法调整：SHOW STATUS LIKE ‘Qcache%’; 如果Qcache_lowmem_prunes该参数记录有多少条查询因为内存不足而被移除出查询缓存。通过这个值，用户可以适当的调整缓存大小。如果该值非常大，则表明经常出现缓冲不够的情况，需要增加缓存大小Qcache_free_memory：查询缓存的内存大小，通过这个参数可以很清晰的知道当前系统的查询内存是否够用，是多了，还是不够用，我们可以根据实际情况做出调整。一般情况下 4G 内存设置 64M 足够了。

		8、thread_cache_size

		表示可以重新利用保存在缓存中线程的数，参考如下值：1G  —> 8; 2G  —> 16; 3G  —> 32; 3G  —> 64
		除此之外，还有几个比较关键的参数

		9、thread_concurrency

		这个值设置为 CPU 核数的2倍即可。

		10、wait_timeout

		表示空闲的连接超时时间，默认是：28800s，这个参数是和 interactive_timeout 一起使用的，也就是说要想让 wait_timeout 生效，必须同时设置 interactive_timeout，建议他们两个都设置为10。

		11、max_connect_errors

		是一个 MySQL 中与安全有关的计数器值，它负责阻止过多尝试失败的客户端以防止暴力破解密码的情况。与性能并无太大关系。为了避免一些错误我们一般都设置比较大，比如说10000。

		12、max_connections

		最大的连接数，根据业务请求量适当调整，设置 500 足够。

		13、max_user_connections

		是指同一个账号能够同时连接到 mysql 服务的最大连接数。设置为 0 表示不限制。通常我们设置为 100 足够。


6.什么是事务?

	
	事务的机制通常被概括为“ACID”原则即原子性（Atom）、稳定性（C）、隔离性（Isolation）和持久性（Durability）。 
　　原子性：构成事务的的所有操作必须是一个逻辑单元，要么全部执行，要么全部不执行。 
　　稳定性：数据库在事务执行前后状态都必须是稳定的。 
　　隔离性：事务之间不会相互影响。 
　　持久性：事务执行成功后必须全部写入磁盘

	事务隔离性:
		数据库事务会导致脏读、不可重复读和幻影读等问题。 
	　　脏读：事务还没提交，他的修改已经被其他事务看到。 
	　　不可重复读：同一事务中两个相同SQL读取的内容可能不同。两次读取之间其他事务提交了修改可能会造成读取数据不一致。 
	　　幻影数据：同一个事务突然发现他以前没发现的数据。和不可重复读很类似，不过修改数据改成增加数据。 

7.如何实现跨库关联？

	比如说，要关联的表是：机器A上的数据库A中的表A && 机器B上的数据库B中的表B。
	需要进行关联查询： select a from A left join B On ... WHERE...

	解决方案：采用的是基于MySQL的federated引擎的建表方式
	如果有FEDERATED引擎，但Support是NO，说明你的mysql安装了这个引擎，但没启用，去my.cnf文件末添加一行 federated ，重启mysql即可；
	通过FEDERATED引擎创建的表只是在本地有表定义文件，数据文件则存在于远程数据库中，通过这个引擎可以实现类似Oracle 下DBLINK的远程数据访问功能。就是说，这种建表方式只会在数据库A中创建一个表B的表结构文件，表的索引、数据等文件还是在机器B上的数据库B中，相当于只是在数据库A中创建了表B的一个快捷方式。
		CREATE TABLE IF NOT EXISTS `logintoken` (
			`id` int(11) NOT NULL AUTO_INCREMENT,
			`type` char(1) NOT NULL DEFAULT '0',
			`loginName` varchar(20) DEFAULT NULL,
			`token` varchar(2000) DEFAULT NULL,
			`tokenExpiredTime` timestamp NULL DEFAULT NULL,
			PRIMARY KEY (`id`)
		) ENGINE =FEDERATED CONNECTION='mysql://root:root@192.168.5.102:3306/zysso/logintoken';
		数据库类型：//用户名：密码@IP地址：端口/库名/表名

	需要注意的几点：
		1. 本地的表结构必须与远程的完全一样。
		2.远程数据库目前仅限MySQL
		3.不支持事务
		4.不支持表结构修改

8. mysql都有哪些锁？
	MySQL有三种锁的级别：页级、表级、行级。

	表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。

	行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。

	页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

9.何为死锁？
	所谓死锁<DeadLock>: 是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.

	此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等待的进程称为死锁进程.
	
	表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB

10.死锁的常见情景？
	1）不同表相同记录行锁冲突（操作的顺序不同）
	2）相同表记录行锁冲突（顺序不同）
	3）不同索引锁冲突（主键 联合索引）

	如何尽可能避免死锁
	1）以固定的顺序访问表和行。比如对第2节两个job批量更新的情形，简单方法是对id列表先排序，后执行，这样就避免了交叉等待锁的情形；又比如对于3.1节的情形，将两个事务的sql顺序调整为一致，也能避免死锁。

	2）大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。

	3）在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。

	4）降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。

	5）为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。

11.如何快速的定位死锁的原因？
	1）通过应用业务日志定位到问题代码，找到相应的事务对应的sql
	2）找DBA执行下show InnoDB STATUS看看最近死锁的日志。
	3）确定数据库的隔离级别 select @@global.tx_isolation
	数据库都会有事务隔离级别的概念：1）未提交读（Read uncommitted）；2）已提交读（Read committed（RC））；3）可重复读（Repeatable read（RR））；4）可串行化（Serializable）。我们较常使用的是RC和RR。

     提交读(RC)：只能读取到已经提交的数据。

     可重复读(RR)：在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。










