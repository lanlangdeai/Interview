MySQL有关问题

1.MySQL数据库中的字段类型varchar和char的主要区别是什么?

Varchar是变长，节省存储空间，char是固定长度。查找效率char型更快，因为varchar是非定长，必须先查找长度，然后进行数据的提取，比char定长类型多了一个步骤，所以效率低一些。

2.MySQL数据库的常用存储引擎以及它们的区别？

MyISAM：
	不支持事务，表锁，易产生碎片，要经常优化，读写速度较快，支持全文索引。
	myisam会创建三个文件： 
		1.xxx(表名).frm –>表结构 
		2.xxx(表名).myi –>索引 
		3.xxx(表名).myd –>数据文件

InnoDB：
	支持外键，事务，行锁，有崩溃恢复能力。读写速度比MyISAM慢，5.6之后支持全文索引。
	存储引擎是基于表的，而不是数据库 
	innodb会创建两个文件:
		1.xxx(表名).frm ->表结构
		2.xxx(表名).ibd ->数据+索引

3.Mysql的读写分离?

读写分离的实现原理就是在执行SQL语句的时候，判断到底是读操作还是写操作，把读的操作转向到读服务器上（从服务器，一般是多台），写的操作转到写的服务器上（主服务器，一般是一台，视数据量来看）。当然为了保证多台数据库数据的一致性，需要主从复制。

MySQL读写分离基本原理是让master数据库处理写操作，slave数据库处理读操作。master将写操作的变更同步到各个slave节点。

	主从复制几种方式:
		同步复制

		所谓的同步复制，意思是master的变化，必须等待slave-1,slave-2,...,slave-n完成后才能返回。

		这样，显然不可取，也不是MYSQL复制的默认设置。比如，在WEB前端页面上，用户增加了条记录，需要等待很长时间。


		异步复制

		如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心。MYSQL的默认设置。


		半同步复制

		master只保证slaves中的一个操作成功，就返回，其他slave不管。

		这个功能，是由google为MYSQL引入的。


	常见问题:
		问题1：master的写操作，slaves被动的进行一样的操作，保持数据一致性，那么slave是否可以主动的进行写操作？

			假设slave可以主动的进行写操作，slave又无法通知master，这样就导致了master和slave数据不一致了。因此slave不应该进行写操作，至少是slave上涉及到复制的数据库不可以写。实际上，这里已经揭示了读写分离的概念。
 
		问题2：主从复制中，可以有N个slave,可是这些slave又不能进行写操作，要他们干嘛？

			可以实现数据备份。

			类似于高可用的功能，一旦master挂了，可以让slave顶上去，同时slave提升为master。

			异地容灾，比如master在北京，地震挂了，那么在上海的slave还可以继续。

			主要用于实现scale out,分担负载,可以将读的任务分散到slaves上。

		问题3：主从复制中有master,slave1,slave2,...等等这么多MYSQL数据库，那比如一个JAVA WEB应用到底应该连接哪个数据库?
 
			当 然，我们在应用程序中可以这样，insert/delete/update这些更新数据库的操作，用connection(for master)进行操作，select用connection(for slaves)进行操作。那我们的应用程序还要完成怎么从slaves选择一个来执行select，例如简单的轮循算法。

			这样的话，相当于应用程序完成了SQL语句的路由，而且与MYSQL的主从复制架构非常关联，一旦master挂了，某些slave挂了，那么应用程序就要修改了。能不能让应用程序与MYSQL的主从复制架构没有什么太多关系呢？
			找一个组件，application program只需要与它打交道，用它来完成MYSQL的代理，实现SQL语句的路由。
 			mysql proxy并不负责，怎么从众多的slaves挑一个？可以交给另一个组件(比如haproxy)来完成。
			这就是所谓的MYSQL READ WRITE SPLITE，MYSQL的读写分离。

		问题4：当master的二进制日志每产生一个事件，都需要发往slave，如果我们有N个slave,那是发N次，还是只发一次？

			如果只发一次，发给了slave-1，那slave-2,slave-3,...它们怎么办？

			显 然，应该发N次。实际上，在MYSQL master内部，维护N个线程，每一个线程负责将二进制日志文件发往对应的slave。master既要负责写操作，还的维护N个线程，负担会很重。可 以这样，slave-1是master的从，slave-1又是slave-2,slave-3,...的主，同时slave-1不再负责select。 slave-1将master的复制线程的负担，转移到自己的身上。这就是所谓的多级复制的概念。

		问题5：当一个select发往mysqlproxy，可能这次由slave-2响应，下次由slave-3响应，这样的话，就无法利用查询缓存了。

			应该找一个共享式的缓存，比如memcache来解决。将slave-2,slave-3,...这些查询的结果都缓存至mamcache中







